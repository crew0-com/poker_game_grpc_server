// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: game_message.sql

package database

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
)

const addGameMessage = `-- name: AddGameMessage :one
INSERT INTO game_messages (game_id, game_room_id,  message)
VALUES ($1, $2, $3) returning game_id, game_room_id, message_id, message, created_at
`

type AddGameMessageParams struct {
	GameID     uuid.UUID       `json:"game_id"`
	GameRoomID uuid.UUID       `json:"game_room_id"`
	Message    json.RawMessage `json:"message"`
}

// desc: Adds a game message
func (q *Queries) AddGameMessage(ctx context.Context, arg AddGameMessageParams) (GameMessage, error) {
	row := q.queryRow(ctx, q.addGameMessageStmt, addGameMessage, arg.GameID, arg.GameRoomID, arg.Message)
	var i GameMessage
	err := row.Scan(
		&i.GameID,
		&i.GameRoomID,
		&i.MessageID,
		&i.Message,
		&i.CreatedAt,
	)
	return i, err
}

const getGameMessages = `-- name: GetGameMessages :many
SELECT game_id, game_room_id, message_id, message, created_at FROM game_messages WHERE game_id = $1 ORDER BY message_id DESC LIMIT 100
`

// desc: Returns all game messages
func (q *Queries) GetGameMessages(ctx context.Context, gameID uuid.UUID) ([]GameMessage, error) {
	rows, err := q.query(ctx, q.getGameMessagesStmt, getGameMessages, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GameMessage{}
	for rows.Next() {
		var i GameMessage
		if err := rows.Scan(
			&i.GameID,
			&i.GameRoomID,
			&i.MessageID,
			&i.Message,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginatedGameMessageByGameRoom = `-- name: PaginatedGameMessageByGameRoom :many
SELECT game_id, game_room_id, message_id, message, created_at FROM game_messages WHERE game_room_id = $1 ORDER BY message_id DESC LIMIT $2 OFFSET $3
`

type PaginatedGameMessageByGameRoomParams struct {
	GameRoomID uuid.UUID `json:"game_room_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) PaginatedGameMessageByGameRoom(ctx context.Context, arg PaginatedGameMessageByGameRoomParams) ([]GameMessage, error) {
	rows, err := q.query(ctx, q.paginatedGameMessageByGameRoomStmt, paginatedGameMessageByGameRoom, arg.GameRoomID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GameMessage{}
	for rows.Next() {
		var i GameMessage
		if err := rows.Scan(
			&i.GameID,
			&i.GameRoomID,
			&i.MessageID,
			&i.Message,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paginatedGameMessages = `-- name: PaginatedGameMessages :many
SELECT game_id, game_room_id, message_id, message, created_at FROM game_messages WHERE game_id = $1 ORDER BY message_id DESC LIMIT $2 OFFSET $3
`

type PaginatedGameMessagesParams struct {
	GameID uuid.UUID `json:"game_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

// desc: Returns a page of game messages
func (q *Queries) PaginatedGameMessages(ctx context.Context, arg PaginatedGameMessagesParams) ([]GameMessage, error) {
	rows, err := q.query(ctx, q.paginatedGameMessagesStmt, paginatedGameMessages, arg.GameID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GameMessage{}
	for rows.Next() {
		var i GameMessage
		if err := rows.Scan(
			&i.GameID,
			&i.GameRoomID,
			&i.MessageID,
			&i.Message,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
